<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thinture GPS</title>
    <link rel="icon" type="image/x-icon" href="/THINTURE_IMAGE/favicon.jpg">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>

    <!-- Leaflet CSS (must be in <head>) -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment/min/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment-timezone/builds/moment-timezone-with-data.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
	<!-- Add this CDN link for Marker Clustering -->
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.1/MarkerCluster.css" />
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.1/MarkerCluster.Default.css" />
	<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.markercluster/1.5.1/leaflet.markercluster.js"></script>

    <!-- Flatpickr DateTime Picker -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    
    <link rel="stylesheet" type="text/css" th:href="@{/css/playback.css}">
    <link rel="stylesheet" type="text/css" th:href="@{/css/style.css}">
    
    <style>
        #map {
            width: 100%;
            height: 100vh;
        }
        
        /* Improved Speedometer positioning */
        #speedometer-toggle-wrapper {
            position: absolute;
            top: 340px;
            right: 20px;
            z-index: 10001;
            background: rgba(255, 255, 255, 0.8);
            padding: 8px;
            border-radius: 8px;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            cursor: pointer;
        }
        
		#speedometer-container {
		    position: absolute;
		    bottom: 20px;
		    left: 20px;
		    z-index: 9999;
		    border-radius: 10px;
		    padding: 15px;
		    width: 250px;
		    opacity: 1 !important;
		    visibility: visible !important;
		    transform: translateY(0) !important;
		}



        #speedometer-container.visible {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }

        #speedDisplay {
            font-size: 1.4rem;
            font-weight: bold;
            color: rgb(0, 0, 64);
            margin-top: 10px;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
        }

        canvas {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 8px;
        }

        #toggleSpeedometer {
            font-size: 24px;
            color: rgb(0,0,64);
            cursor: pointer;
        }
        
        /* Export buttons */
        .export-buttons {
            margin-top: 15px;
            display: flex;
            justify-content: space-between;
        }
        
        .export-btn {
            padding: 8px 12px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        
        .export-btn:hover {
            background-color: #0056b3;
        }
        
        /* Modern panel improvements */
        .modern-panel {
            max-height: 80vh;
            overflow-y: auto;
        }
        
        /* Trip statistics */
        .trip-stats {
            background-color: #f8f9fa;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
        }
        
        /* Add styling for trip stat items */
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        
        .stat-label {
            font-weight: bold;
        }
        
        /* Legend improvements */
        .legend {
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* Heatmap toggle */
        #heatmap-toggle {
            position: absolute;
            top: 20px;
            left: 80px;
            z-index: 1000;
            background: white;
            padding: 6px 10px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-size: 14px;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <div th:insert="~{navigation_admin :: navbar_admin}"></div>
    
    <!-- Improved FontAwesome icon with tooltip 
    <div id="speedometer-toggle-wrapper" title="Toggle Speedometer">
        <i class="fa-solid fa-gauge-high" id="toggleSpeedometer"></i>
    </div>
	-->
    <!-- Heatmap toggle button -->
    <button id="heatmap-toggle" title="Toggle Heatmap View">
        <i class="fas fa-fire"></i> Heatmap
    </button>

    <!-- Improved Speedometer container -->
    <div id="speedometer-container">
        <canvas id="speedometer" width="220" height="220"></canvas>
        <!-- <div id="speedDisplay"><b>Speed: 0 km/h</b></div>-->
    </div>

    <div id="map"></div>
    
    <!-- Toggle button outside panel -->
    <button id="panel-toggle" class="panel-toggle-button">‚ò∞</button>
    <div id="mapSwitcher">
        <button id="fullScreenBtn" class="map-button" onclick="toggleFullScreen()">
            <i class="fas fa-expand"></i>
        </button>
    </div>
    
    <div class="modern-panel" id="modern-panel">
        <div class="tabs">
            <button class="tab-button active" onclick="switchTab('history')">History</button>
            <button class="tab-button" onclick="switchTab('settings')">Settings</button>
            <button class="tab-button" onclick="switchTab('alerts')">Alerts</button>
            <button class="tab-button" onclick="switchTab('export')">Export</button>
        </div>

        <div id="tab-history" class="tab-content active-tab">
            <label>Device ID</label>
            <input type="text" id="device-id" placeholder="Enter Device ID" rea
			>
            <label>From</label>
            <input type="text" id="from-date" placeholder="Select From Date & Time">
            <label>To</label>
            <input type="text" id="to-date" placeholder="Select To Date & Time">
            
            <div class="d-flex justify-content-between align-items-center mb-2">
                <label>Speed</label>
                <div>
                    <button class="btn btn-sm btn-outline-primary me-1" onclick="setSpeed(1)">1x</button>
                    <button class="btn btn-sm btn-outline-primary me-1" onclick="setSpeed(2)">2x</button>
                    <button class="btn btn-sm btn-outline-primary" onclick="setSpeed(5)">5x</button>
                </div>
            </div>

            <input type="range" id="progress-bar" min="0" value="0" step="1" style="width: 100%;">

            <button class="button" onclick="loadHistory()">üîç Load History</button>
            <button class="button" onclick="toggleReplay()" id="playback-btn">‚ñ∂Ô∏è Play</button>
            <button class="button" onclick="calculateSummaryStats()">üìä Trip Summary</button>

            <div class="trip-stats">
                <div class="stat-item">
                    <span class="stat-label">Total Distance:</span>
                    <span id="total-distance-display">0 km</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Max Speed:</span>
                    <span id="max-speed-display">0 km/h</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Avg Speed:</span>
                    <span id="avg-speed-display">0 km/h</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">Travel Time:</span>
                    <span id="travel-time-display">00:00:00</span>
                </div>
            </div>
        </div>

        <div id="tab-settings" class="tab-content">
            <label>Time Zone</label>
            <select id="time-zone">
                <option value="auto">Auto</option>
                <option value="Asia/Kolkata">IST</option>
                <option value="America/New_York">EST</option>
                <option value="Europe/London">GMT</option>
            </select>
            
            <label>Map Style</label>
            <select id="map-style" onchange="changeMapStyle()">
                <option value="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png">OpenStreetMap</option>
                <option value="https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png">Carto Light</option>
                <option value="https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png">Carto Dark</option>
                <option value="https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}">Satellite</option>
            </select>
            
            <label>Vehicle Icon</label>
            <select id="vehicle-icon" onchange="updateVehicleIcon()">
                <option value="/THINTURE_IMAGE/car/green/car0.png">Green Car</option>
                <option value="/THINTURE_IMAGE/car/blue/car0.png">Blue Car</option>
                <option value="/THINTURE_IMAGE/car/red/car0.png">Red Car</option>
                <option value="/THINTURE_IMAGE/car/yellow/car0.png">Yellow Car</option>
            </select>
            
            <label>Route Color</label>
            <input type="color" id="route-color" value="#0000FF" onchange="updateRouteColor()">
        </div>

        <div id="tab-alerts" class="tab-content">
            <label><input type="checkbox" id="show-start" checked> Show Start Point</label><br>
            <label><input type="checkbox" id="show-end" checked> Show End Point</label><br>
            <label><input type="checkbox" id="show-idle" checked> Show Idle Info</label><br>
            <label><input type="checkbox" id="show-parked" checked> Show Parked Info</label><br>
            <label><input type="checkbox" id="show-alerts" checked> Show Speed Alerts</label><br>
            <label>Speed Alert Threshold (km/h)</label>
            <input type="number" id="speed-threshold" value="80" min="0" max="200">
        </div>
        
        <div id="tab-export" class="tab-content">
            <h4>Export Trip Data</h4>
            <p>Download your trip data in various formats:</p>
            
            <div class="export-buttons">
                <button class="export-btn" onclick="exportToPDF()">
                    <i class="fas fa-file-pdf"></i> PDF Report
                </button>
                <button class="export-btn" onclick="exportToCSV()">
                    <i class="fas fa-file-csv"></i> CSV Data
                </button>
            </div>
            
            <div class="mt-4">
                <h5>Share Trip</h5>
                <button class="export-btn w-100 mt-2" onclick="generateShareableLink()">
                    <i class="fas fa-share-alt"></i> Generate Link
                </button>
                <div id="shareable-link-container" class="mt-3" style="display: none;">
                    <input type="text" id="shareable-link" class="form-control" readonly>
                    <button class="btn btn-sm btn-outline-primary mt-2" onclick="copyShareableLink()">
                        <i class="fas fa-copy"></i> Copy Link
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="legend">
        <div><span style="background: blue"></span> Route</div>
        <div><span style="background: green"></span> Start</div>
        <div><span style="background: red"></span> End</div>
        <div><span style="background: orange"></span> Idle</div>
        <div><span style="background: darkred"></span> Parked</div>
        <div><span style="background: purple"></span> Speed Alert</div>
    </div>

    <script>
        // Global variables
        let map, replayData = [], carMarker = null, routePolyline = null;
        let replayIndex = 0, isPlaying = false, replayTimeout;
        let idleStart = null, parkedStart = null;
        let idleMarkers = [], parkedMarkers = [], speedAlertMarkers = [], replaySpeed = 1;
        let heatmapLayer = null, isHeatmapActive = false;
        
        // Speedometer variables
        let speedometerCanvas, speedometerCtx;
        
        // Statistics variables
        let maxRecordedSpeed = 0, totalSpeedSum = 0, speedReadingsCount = 0;

        // Initialize when DOM is loaded
        document.addEventListener("DOMContentLoaded", function() {
            console.log("DOM fully loaded, initializing map...");
            initMap();
            initSpeedometer();
            setupEventListeners();
            
            // Set default dates for convenience
            const now = moment();
            const yesterday = moment().subtract(1, 'day');
            
            document.getElementById("from-date").value = yesterday.format("YYYY-MM-DD HH:mm:ss");
            document.getElementById("to-date").value = now.format("YYYY-MM-DD HH:mm:ss");
        });

        function initMap() {
            try {
                // Initialize the map
                map = L.map('map').setView([20.5937, 78.9629], 5);
                changeMapStyle(); // Use the dropdown value
                console.log("Map initialized successfully");
            } catch (error) {
                console.error("Error initializing map:", error);
                // Show error to user
                Swal.fire({
                    icon: 'error',
                    title: 'Map Error',
                    text: 'Could not initialize map. Please check your connection and try refreshing the page.',
                });
            }
        }

        // Initialize speedometer with improved design
        function initSpeedometer() {
            speedometerCanvas = document.getElementById("speedometer");
            if (!speedometerCanvas) {
                console.error("Speedometer canvas not found");
                return;
            }
            
            speedometerCtx = speedometerCanvas.getContext("2d");
            
            // Initial draw
            drawSpeedometer(0);
        }

        // Improved speedometer drawing function
        function drawSpeedometer(speed) {
            if (!speedometerCtx) return;
            
            const canvas = speedometerCanvas;
            const ctx = speedometerCtx;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const width = canvas.width;
            const height = canvas.height;
            const centerX = width / 2;
            const centerY = height;
            const radius = Math.min(width, height * 2) / 2 - 10;
            const maxSpeed = 240; // Maximum speed on gauge
            
            // Draw background arc
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, Math.PI, 0, false);
            ctx.lineWidth = 10;
            ctx.strokeStyle = "#e0e0e0";
            ctx.stroke();
            
            // Calculate angle for current speed
            const speedAngle = Math.PI - (speed / maxSpeed) * Math.PI;
            
            // Draw colored arc based on speed
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, Math.PI, speedAngle, true);
            
            // Create gradient based on speed
            let arcColor;
            if (speed < 60) {
                arcColor = "#4caf50"; // Green for low speed
            } else if (speed < 120) {
                arcColor = "#ffeb3b"; // Yellow for medium speed
            } else {
                arcColor = "#f44336"; // Red for high speed
            }
            
            ctx.lineWidth = 10;
            ctx.strokeStyle = arcColor;
            ctx.stroke();
            
            // Draw speed ticks and labels
            for (let i = 0; i <= maxSpeed; i += 40) {
                const angle = Math.PI - (i / maxSpeed) * Math.PI;
                const x1 = centerX + (radius - 5) * Math.cos(angle);
                const y1 = centerY + (radius - 5) * Math.sin(angle);
                const x2 = centerX + (radius - 20) * Math.cos(angle);
                const y2 = centerY + (radius - 20) * Math.sin(angle);
                
                // Draw tick
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.lineWidth = 2;
                ctx.strokeStyle = "#333";
                ctx.stroke();
                
                // Draw label
                ctx.font = "bold 12px Arial";
                ctx.fillStyle = "#333";
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                
                const labelX = centerX + (radius - 35) * Math.cos(angle);
                const labelY = centerY + (radius - 35) * Math.sin(angle);
                
                ctx.fillText(i.toString(), labelX, labelY);
            }
            
            // Draw needle
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(
                centerX + (radius - 20) * Math.cos(speedAngle),
                centerY + (radius - 20) * Math.sin(speedAngle)
            );
            ctx.lineWidth = 3;
            ctx.strokeStyle = "#f44336"; // Red needle
            ctx.stroke();
            
            // Draw needle center
            ctx.beginPath();
            ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
            ctx.fillStyle = "#333";
            ctx.fill();
            ctx.strokeStyle = "#c0c0c0";
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Update speed text display
            if (document.getElementById("speedDisplay")) {
                document.getElementById("speedDisplay").innerHTML = `<b>Speed: ${Math.round(speed)} km/h</b>`;
            }
        }

        function switchTab(tabId) {
            document.querySelectorAll(".tab-button").forEach(btn => btn.classList.remove("active"));
            document.querySelectorAll(".tab-content").forEach(tab => tab.classList.remove("active-tab"));
            document.querySelector(`.tab-button[onclick*="${tabId}"]`).classList.add("active");
            document.getElementById("tab-" + tabId).classList.add("active-tab");
        }

        function convertToUTC(dateString, timeZone) {
            return moment.tz(dateString, timeZone).utc().format("YYYY-MM-DD HH:mm:ss");
        }

        function convertToLocalTime(utcDate, timeZone) {
            return timeZone === 'auto'
                ? moment.utc(utcDate).local().format("YYYY-MM-DD HH:mm:ss")
                : moment.utc(utcDate).tz(timeZone).format("YYYY-MM-DD HH:mm:ss z");
        }

        function formatDuration(start, end) {
            const diff = moment(end).diff(moment(start), 'seconds');
            const duration = moment.duration(diff, 'seconds');
            return `${String(duration.hours()).padStart(2, '0')}:${String(duration.minutes()).padStart(2, '0')}:${String(duration.seconds()).padStart(2, '0')}`;
        }

        function drawPolyline(data) {
            if (routePolyline) map.removeLayer(routePolyline);
            const latLngs = data.map(p => [p.latitude, p.longitude]);
            const routeColor = document.getElementById("route-color").value;
            routePolyline = L.polyline(latLngs, { color: routeColor, weight: 5 }).addTo(map);
            map.fitBounds(routePolyline.getBounds());
        }

        async function loadHistory() {
            const deviceID = document.getElementById("device-id").value.trim();
            const fromDate = document.getElementById("from-date").value;
            const toDate = document.getElementById("to-date").value;
            const timeZone = document.getElementById("time-zone").value;

            if (!deviceID || !fromDate || !toDate) {
                Swal.fire({
                    icon: 'warning',
                    title: 'Missing Data',
                    text: 'Please provide device ID and date range.',
                    confirmButtonText: 'OK'
                });
                return;
            }

            // Show SweetAlert loading dialog
            Swal.fire({
                title: '‚è≥ Please wait...',
                text: 'Fetching vehicle history...',
                allowOutsideClick: false,
                didOpen: () => {
                    Swal.showLoading();
                }
            });

            const from = convertToUTC(fromDate, timeZone);
            const to = convertToUTC(toDate, timeZone);

            try {
                const res = await fetch(`/api/vehicle/history/${deviceID}?from=${encodeURIComponent(from)}&to=${encodeURIComponent(to)}`);
                if (!res.ok) throw new Error("Failed to fetch data");
                const data = await res.json();
                replayData = data;
                
                // Reset statistics
                maxRecordedSpeed = 0;
                totalSpeedSum = 0;
                speedReadingsCount = 0;
                
                // Calculate and update statistics
                replayData.forEach(point => {
                    const speed = parseFloat(point.speed) || 0;
                    maxRecordedSpeed = Math.max(maxRecordedSpeed, speed);
                    totalSpeedSum += speed;
                    speedReadingsCount++;
                });
                
                updateTotalDistance();
                updateSpeedStats();

                document.getElementById("progress-bar").max = data.length - 1;
                document.getElementById("progress-bar").value = 0;
                
                // Clear existing markers
                clearAllMarkers();
                
                drawPolyline(data);
                
                if (data.length > 0) {
                   // if (document.getElementById("show-start").checked) {
                    //    const startIcon = L.icon({ iconUrl: '/THINTURE_IMAGE/car/start.png', iconSize: [30, 30], iconAnchor: [15, 30] });
                      //  L.marker([data[0].latitude, data[0].longitude], { icon: startIcon }).addTo(map)
                        //    .bindPopup(`<b>Start Point</b><br>${convertToLocalTime(data[0].timestamp, timeZone)}`);
                   // }
                  //  if (document.getElementById("show-end").checked) {
                     //   const endIcon = L.icon({ iconUrl: '/THINTURE_IMAGE/car/end.png', iconSize: [30, 30], iconAnchor: [15, 30] });
                     //   const last = data[data.length - 1];
                      //  L.marker([last.latitude, last.longitude], { icon: endIcon }).addTo(map)
                        //    .bindPopup(`<b>End Point</b><br>${convertToLocalTime(last.timestamp, timeZone)}`);
                   // }
                    
                    // Create heatmap if data is available
                    createHeatmapLayer(data);
                    
                    // Close SweetAlert
                    Swal.close();
                    
                    // Start replay
                    startReplay();
                } else {
                    Swal.fire({
                        icon: 'info',
                        title: 'No Data',
                        text: 'No tracking data available for the selected period.',
                    });
                }
            } catch (err) {
                console.error("Error fetching data:", err);
                Swal.fire({
                    icon: 'error',
                    title: 'Data Error',
                    text: 'Could not load history data. Please check the device ID and try again.',
                });
            }
        }

        function clearAllMarkers() {
            if (carMarker) map.removeLayer(carMarker);
            carMarker = null;
            
            idleMarkers.forEach(m => map.removeLayer(m));
            parkedMarkers.forEach(m => map.removeLayer(m));
            speedAlertMarkers.forEach(m => map.removeLayer(m));
            
            idleMarkers = [];
            parkedMarkers = [];
            speedAlertMarkers = [];
            
            if (heatmapLayer) {
                map.removeLayer(heatmapLayer);
                heatmapLayer = null;
            }
        }

        function startReplay() {
            if (!replayData.length) return;
            isPlaying = true;
            replayIndex = 0;
            document.getElementById("playback-btn").innerText = "‚è∏Ô∏è Pause";
            animateMarker();
        }

		function animateMarker() {
		    clearTimeout(replayTimeout);
		    if (!isPlaying || replayIndex >= replayData.length) {
		        isPlaying = false;
		        document.getElementById("playback-btn").innerText = "‚ñ∂Ô∏è Play";
		        return;
		    }

		    const point = replayData[replayIndex];
		    const timeZone = document.getElementById("time-zone").value;
		    const latlng = [point.latitude, point.longitude];
		    const rotation = point.course ? ((parseFloat(point.course) % 360) + 360) % 360 : 0;

		    // Update speedometer with the current speed
		    const speed = parseFloat(point.speed) || 0;  // Get the speed from the point data
		    drawSpeedometer(speed);  // Call the function to update the speedometer

		    // Update progress bar
		    document.getElementById("progress-bar").value = replayIndex;

		    const icon = L.divIcon({
		        className: '',
		        html: `<div style="transform: rotate(${rotation}deg); transition: transform 0.3s ease;"><img src="/THINTURE_IMAGE/car/green/car0.png" style="width: 40px; height: 40px;"></div>`,
		        iconSize: [40, 40],
		        iconAnchor: [20, 20]
		    });

		    if (!carMarker) carMarker = L.marker(latlng, { icon }).addTo(map);
		    else {
		        carMarker.setLatLng(latlng);
		        carMarker.setIcon(icon);
		    }

		    carMarker.bindPopup(`
		        <b>üöó Vehicle Status:</b> ${point.vehicleStatus}<br>
		        <b>‚è±Ô∏è Speed:</b> ${point.speed} km/h<br>
		        <b>üìÖ Timestamp:</b> ${convertToLocalTime(point.timestamp, timeZone)}<br>
		        <b>üìç Latitude:</b> ${point.latitude}<br>
		        <b>üìç Longitude:</b> ${point.longitude}
		    `);

		    // ‚úÖ IDLE marker if 2+ min
		    if (point.vehicleStatus === "IDLE" && document.getElementById("show-idle").checked) {
		        if (!idleStart) idleStart = point.timestamp;

		        const idleDurationSec = moment(point.timestamp).diff(moment(idleStart), 'seconds');
		        
		        // Show idle marker if duration is greater than or equal to 2 minutes (120 seconds)
		        if (idleDurationSec >= 120) {
		            const duration = formatDuration(idleStart, point.timestamp);

		            // Change the icon if idle time is greater than or equal to 2 minutes
		            const idleIcon = L.icon({ 
		                iconUrl: '/THINTURE_IMAGE/idlenew-Photo.png',  // Use a high idle icon (large, prominent)
		                iconSize: [50, 50], // Adjust icon size for high idle time
		                iconAnchor: [25, 50] 
		            });

		            const marker = L.marker(latlng, { icon: idleIcon }).addTo(map).bindPopup(`
		                üöó <b>IDLE Start:</b> ${convertToLocalTime(idleStart, timeZone)}<br>
		                üïí <b>IDLE End:</b> ${convertToLocalTime(point.timestamp, timeZone)}<br>
		                üìç <b>Latitude:</b> ${point.latitude}<br>
		                üìç <b>Longitude:</b> ${point.longitude}<br>
		                ‚è≥ <b>Total Duration:</b> ${duration}
		            `);

		            idleMarkers.push(marker);
		            idleStart = null; // reset after showing
		        }
		    } else {
		        idleStart = null;
		    }

		    // ‚úÖ PARKED marker (no duration check)
		    if (point.vehicleStatus === "PARKED" && document.getElementById("show-parked").checked) {
		        if (!parkedStart) parkedStart = point.timestamp;

		        const duration = formatDuration(parkedStart, point.timestamp);
		        const parkedIcon = L.icon({ iconUrl: '/THINTURE_IMAGE/parkednew-Photo.png', iconSize: [40, 40], iconAnchor: [20, 35] });

		        const marker = L.marker(latlng, { icon: parkedIcon }).addTo(map).bindPopup(`
		            üöó <b>PARKED Start:</b> ${convertToLocalTime(parkedStart, timeZone)}<br>
		            üïí <b>PARKED End:</b> ${convertToLocalTime(point.timestamp, timeZone)}<br>
		            üìç <b>Latitude:</b> ${point.latitude}<br>
		            üìç <b>Longitude:</b> ${point.longitude}<br>
		            ‚è≥ <b>Total Duration:</b> ${duration}
		        `);

		        parkedMarkers.push(marker);
		    } else {
		        parkedStart = null;
		    }

		    replayIndex++;
		    replayTimeout = setTimeout(animateMarker, 1000 / replaySpeed);
		}




        function toggleReplay() {
            isPlaying = !isPlaying;
            document.getElementById("playback-btn").innerText = isPlaying ? "‚è∏Ô∏è Pause" : "‚ñ∂Ô∏è Play";
            if (isPlaying) {
                animateMarker();
            } else {
                clearTimeout(replayTimeout);
            }
        }

        function setSpeed(factor) {
            replaySpeed = factor;
        }

        // Haversine Formula to calculate distance between two points
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 6371;
            const dLat = (lat2 - lat1) * (Math.PI / 180);
            const dLon = (lon2 - lon1) * (Math.PI / 180);

            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                    Math.cos(lat1 * (Math.PI / 180)) * Math.cos(lat2 * (Math.PI / 180)) *
                    Math.sin(dLon / 2) * Math.sin(dLon / 2);

            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // Calculate total distance and update UI
        function updateTotalDistance() {
            if (!replayData || replayData.length < 2) {
                document.getElementById("total-distance-display").textContent = "0 km";
                return;
            }
            
            let totalDistance = 0;
            for (let i = 0; i < replayData.length - 1; i++) {
                totalDistance += calculateDistance(
                    replayData[i].latitude, replayData[i].longitude,
                    replayData[i + 1].latitude, replayData[i + 1].longitude
                );
            }

            const formatted = `${totalDistance.toFixed(2)} km`;
            document.getElementById("total-distance-display").textContent = formatted;
            
            // Also update travel time
            const start = replayData[0];
            const end = replayData[replayData.length - 1];
            document.getElementById("travel-time-display").textContent = formatDuration(start.timestamp, end.timestamp);
        }
        
        // Update speed stats
        function updateSpeedStats() {
            if (!replayData || replayData.length === 0) return;
            
            document.getElementById("max-speed-display").textContent = `${maxRecordedSpeed.toFixed(1)} km/h`;
            
            const avgSpeed = speedReadingsCount > 0 ? (totalSpeedSum / speedReadingsCount) : 0;
            document.getElementById("avg-speed-display").textContent = `${avgSpeed.toFixed(1)} km/h`;
        }

        async function calculateSummaryStats() {
            if (!replayData.length) {
                Swal.fire({
                    icon: 'warning',
                    title: 'No Data',
                    text: 'Please load history data first.',
                });
                return;
            }

            // We've already calculated most stats during loading
            const avgSpeed = speedReadingsCount > 0 ? (totalSpeedSum / speedReadingsCount) : 0;
            let stopCount = 0, idleCount = 0, parkedCount = 0;

            // Count stops and idle periods by looking for status changes
            let currentStatus = null;
            replayData.forEach(p => {
                if (p.vehicleStatus !== currentStatus) {
                    if (p.vehicleStatus === "PARKED") parkedCount++;
                    if (p.vehicleStatus === "IDLE") idleCount++;
                    currentStatus = p.vehicleStatus;
                }
            });

            stopCount = parkedCount + idleCount;

            const start = replayData[0];
            const end = replayData[replayData.length - 1];

            // Reverse geocoding using Nominatim API
            async function getAddress(lat, lon) {
                try {
                    const response = await fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json`);
                    const result = await response.json();
                    return result.display_name || "Address not found";
                } catch (error) {
                    return "Error fetching address";
                }
            }

            // Show loading while fetching addresses
            Swal.fire({
                title: 'Fetching address data...',
                allowOutsideClick: false,
                didOpen: () => {
                    Swal.showLoading();
                }
            });

            const startAddress = await getAddress(start.latitude, start.longitude);
            const endAddress = await getAddress(end.latitude, end.longitude);
            
            // Calculate total distance
            let totalDistance = 0;
            for (let i = 0; i < replayData.length - 1; i++) {
                totalDistance += calculateDistance(
                    replayData[i].latitude, replayData[i].longitude,
                    replayData[i + 1].latitude, replayData[i + 1].longitude
                );
            }

            Swal.fire({
                title: 'üìä Trip Summary',
                html: `
                    <div style="text-align: left; margin-bottom: 20px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <b>Distance:</b> <span>${totalDistance.toFixed(2)} km</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <b>Max Speed:</b> <span>${maxRecordedSpeed.toFixed(1)} km/h</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <b>Average Speed:</b> <span>${avgSpeed.toFixed(1)} km/h</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <b>Total Stops:</b> <span>${stopCount}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <b>Parking Events:</b> <span>${parkedCount}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <b>Idle Events:</b> <span>${idleCount}</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <b>Duration:</b> <span>${formatDuration(start.timestamp, end.timestamp)}</span>
                        </div>
                    </div>
                    <hr>
                    <div style="text-align: left;">
                        <b>üìç Start Address:</b><br>
                        <div style="margin-bottom: 8px;">${startAddress}</div>
                        <b>üìç End Address:</b><br>
                        <div>${endAddress}</div>
                    </div>
                `,
                icon: 'info',
                toast: false,
                confirmButtonText: 'Close',
                width: 600,
                footer: '<button class="btn btn-sm btn-primary" onclick="exportToPDF()">Export to PDF</button>'
            });
        }

        function toggleFullScreen() {
            const mapContainer = document.getElementById('map');
            const fullScreenBtn = document.getElementById('fullScreenBtn').querySelector('i');

            if (!document.fullscreenElement) {
                mapContainer.requestFullscreen().then(() => {
                    fullScreenBtn.classList.remove('fa-expand');
                    fullScreenBtn.classList.add('fa-compress');
                }).catch(err => {
                    console.error(`Error attempting full-screen mode: ${err.message}`);
                });
            } else {
                document.exitFullscreen().then(() => {
                    fullScreenBtn.classList.remove('fa-compress');
                    fullScreenBtn.classList.add('fa-expand');
                });
            }
        }

        function showAlert(title, status) {
            Swal.fire({
                position: 'top-end',
                icon: status ? 'success' : 'info',
                title: `${title} ${status ? 'enabled' : 'disabled'}`,
                showConfirmButton: false,
                timer: 1500
            });
        }
        
        // Change map style based on selection
        function changeMapStyle() {
            const styleUrl = document.getElementById("map-style").value;
            
            // Remove existing tile layer
            map.eachLayer(layer => {
                if (layer instanceof L.TileLayer) {
                    map.removeLayer(layer);
                }
            });
            
            // Add new tile layer
            L.tileLayer(styleUrl, {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
            }).addTo(map);
        }
        
        // Update route color
        function updateRouteColor() {
            if (routePolyline) {
                const newColor = document.getElementById("route-color").value;
                routePolyline.setStyle({color: newColor});
            }
        }
        
        // Update vehicle icon
        function updateVehicleIcon() {
            // Will be applied on next animation frame
            if (carMarker && isPlaying) {
                const point = replayData[replayIndex-1 >= 0 ? replayIndex-1 : 0];
                const rotation = point.course ? ((parseFloat(point.course) % 360) + 360) % 360 : 0;
                const vehicleIconPath = document.getElementById("vehicle-icon").value;
                
                const icon = L.divIcon({
                    className: '',
                    html: `<div style="transform: rotate(${rotation}deg); transition: transform 0.3s ease;"><img src="${vehicleIconPath}" style="width: 40px; height: 40px;"></div>`,
                    iconSize: [40, 40],
                    iconAnchor: [20, 20]
                });
                
                carMarker.setIcon(icon);
            }
        }
        
        // Export to CSV 
        function exportToCSV() {
            if (!replayData || replayData.length === 0) {
                Swal.fire({
                    icon: 'warning',
                    title: 'No Data',
                    text: 'Please load history data first.'
                });
                return;
            }
            
            const timeZone = document.getElementById("time-zone").value;
            const csvContent = Papa.unparse({
                fields: ["Timestamp", "Latitude", "Longitude", "Speed (km/h)", "Vehicle Status", "Course"],
                data: replayData.map(point => [
                    convertToLocalTime(point.timestamp, timeZone),
                    point.latitude,
                    point.longitude,
                    point.speed,
                    point.vehicleStatus,
                    point.course
                ])
            });
            
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement("a");
            const deviceId = document.getElementById("device-id").value;
            const date = new Date().toISOString().slice(0, 10);
            
            link.href = URL.createObjectURL(blob);
            link.download = `vehicle_${deviceId}_history_${date}.csv`;
            link.style.display = "none";
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            Swal.fire({
                position: 'top-end',
                icon: 'success',
                title: 'CSV exported successfully',
                showConfirmButton: false,
                timer: 2000,
                toast: true
            });
        }
        
        // Export to PDF
        function exportToPDF() {
            if (!replayData || replayData.length === 0) {
                Swal.fire({
                    icon: 'warning',
                    title: 'No Data',
                    text: 'Please load history data first.'
                });
                return;
            }
            
            Swal.fire({
                title: 'Generating PDF...',
                allowOutsideClick: false,
                didOpen: () => {
                    Swal.showLoading();
                }
            });
            
            // Use jsPDF
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            const deviceId = document.getElementById("device-id").value;
            const timeZone = document.getElementById("time-zone").value;
            const start = replayData[0];
            const end = replayData[replayData.length - 1];
            
            // Calculate stats
            let totalDistance = 0;
            for (let i = 0; i < replayData.length - 1; i++) {
                totalDistance += calculateDistance(
                    replayData[i].latitude, replayData[i].longitude,
                    replayData[i + 1].latitude, replayData[i + 1].longitude
                );
            }
            
            // Add title
            doc.setFontSize(18);
            doc.text("Vehicle Trip Report", 105, 15, { align: "center" });
            
            // Add metadata
            doc.setFontSize(12);
            doc.text(`Device ID: ${deviceId}`, 20, 30);
            doc.text(`Date: ${new Date().toLocaleDateString()}`, 20, 37);
            
            // Add trip details
            doc.setFontSize(14);
            doc.text("Trip Details", 20, 50);
            doc.setFontSize(10);
            doc.text(`Start Time: ${convertToLocalTime(start.timestamp, timeZone)}`, 20, 60);
            doc.text(`End Time: ${convertToLocalTime(end.timestamp, timeZone)}`, 20, 67);
            doc.text(`Duration: ${formatDuration(start.timestamp, end.timestamp)}`, 20, 74);
            doc.text(`Distance: ${totalDistance.toFixed(2)} km`, 20, 81);
            doc.text(`Max Speed: ${maxRecordedSpeed.toFixed(1)} km/h`, 20, 88);
            
            const avgSpeed = speedReadingsCount > 0 ? (totalSpeedSum / speedReadingsCount) : 0;
            doc.text(`Average Speed: ${avgSpeed.toFixed(1)} km/h`, 20, 95);
            
            // Add map image
            // Note: This is just a placeholder. In a real implementation,
            // you would need to capture the map as an image and add it.
            doc.text("Trip route map would be displayed here", 105, 120, { align: "center" });
            
            // Save PDF
            doc.save(`vehicle_${deviceId}_report.pdf`);
            
            Swal.fire({
                position: 'top-end',
                icon: 'success',
                title: 'PDF exported successfully',
                showConfirmButton: false,
                timer: 2000,
                toast: true
            });
        }
        
        // Generate shareable link 
        function generateShareableLink() {
            if (!replayData || replayData.length === 0) {
                Swal.fire({
                    icon: 'warning',
                    title: 'No Data',
                    text: 'Please load history data first.'
                });
                return;
            }
            
            const deviceId = document.getElementById("device-id").value;
            const fromDate = document.getElementById("from-date").value;
            const toDate = document.getElementById("to-date").value;
            
            // Create URL parameters
            const params = new URLSearchParams();
            params.append('deviceId', deviceId);
            params.append('from', fromDate);
            params.append('to', toDate);
            
            // Generate link with current URL and parameters
            const shareableLink = `${window.location.origin}${window.location.pathname}?${params.toString()}`;
            
            document.getElementById('shareable-link').value = shareableLink;
            document.getElementById('shareable-link-container').style.display = 'block';
            
            Swal.fire({
                position: 'top-end',
                icon: 'success',
                title: 'Link generated!',
                text: 'You can now copy and share this link.',
                showConfirmButton: false,
                timer: 2000,
                toast: true
            });
        }
        
        // Copy shareable link to clipboard
        function copyShareableLink() {
            const linkInput = document.getElementById('shareable-link');
            linkInput.select();
            document.execCommand('copy');
            
            Swal.fire({
                position: 'top-end',
                icon: 'success',
                title: 'Link copied to clipboard!',
                showConfirmButton: false,
                timer: 1500,
                toast: true
            });
        }
        
        // Create heatmap layer
        function createHeatmapLayer(data) {
            if (!window.L.heatLayer) {
                console.warn("Leaflet.heat plugin is not available. Heatmap cannot be created.");
                document.getElementById('heatmap-toggle').style.display = 'none';
                return;
            }
            
            // Format data for heatmap (lat, lng, intensity)
            const heatmapData = data.map(point => {
                const speed = parseFloat(point.speed) || 0;
                return [
                    parseFloat(point.latitude), 
                    parseFloat(point.longitude), 
                    speed / 5 // Normalize speed for intensity
                ];
            });
            
            heatmapLayer = L.heatLayer(heatmapData, {
                radius: 25,
                blur: 15,
                maxZoom: 17,
                gradient: {0.4: 'blue', 0.6: 'lime', 0.8: 'yellow', 1: 'red'}
            });
            
            // Don't add to map yet, wait for toggle
        }
        
        // Toggle heatmap 
        function toggleHeatmap() {
            if (!heatmapLayer) return;
            
            isHeatmapActive = !isHeatmapActive;
            
            if (isHeatmapActive) {
                map.addLayer(heatmapLayer);
                document.getElementById('heatmap-toggle').classList.add('active');
            } else {
                map.removeLayer(heatmapLayer);
                document.getElementById('heatmap-toggle').classList.remove('active');
            }
        }

        function setupEventListeners() {
            // Set up date pickers with flatpickr
            flatpickr("#from-date", {
                enableTime: true,
                dateFormat: "Y-m-d H:i:S",
                time_24hr: true
            });

            flatpickr("#to-date", {
                enableTime: true,
                dateFormat: "Y-m-d H:i:S",
                time_24hr: true
            });

            // Progress bar event listeners
            document.getElementById("progress-bar").addEventListener("input", () => {
                clearTimeout(replayTimeout);
            });

            document.getElementById("progress-bar").addEventListener("change", (e) => {
                replayIndex = parseInt(e.target.value);
                if (replayIndex < replayData.length) {
                    // Update speedometer when progress bar changes
                    const point = replayData[replayIndex];
                    if (point) {
                        const speed = parseFloat(point.speed) || 0;
                        drawSpeedometer(speed);
                    }
                    animateMarker();
                }
            });

            // Toggle panel
            const toggleBtn = document.getElementById("panel-toggle");
            const panel = document.getElementById("modern-panel");

            toggleBtn.addEventListener("click", () => {
                panel.classList.toggle("show");
                toggleBtn.classList.toggle("open");
                toggleBtn.innerText = panel.classList.contains("show") ? "‚úñ " : "‚ò∞ ";
            });

            // Show/hide markers
            document.getElementById("show-start").addEventListener("change", (e) => {
                showAlert("Start Point", e.target.checked);
            });
            
            document.getElementById("show-end").addEventListener("change", (e) => {
                showAlert("End Point", e.target.checked);
            });
            
            document.getElementById("show-idle").addEventListener("change", (e) => {
                idleMarkers.forEach(marker => map.removeLayer(marker));
                idleMarkers = [];
                showAlert("Idle Info", e.target.checked);
            });
            
            document.getElementById("show-parked").addEventListener("change", (e) => {
                parkedMarkers.forEach(marker => map.removeLayer(marker));
                parkedMarkers = [];
                showAlert("Parked Info", e.target.checked);
            });
            
            document.getElementById("show-alerts").addEventListener("change", (e) => {
                speedAlertMarkers.forEach(marker => map.removeLayer(marker));
                speedAlertMarkers = [];
                showAlert("Speed Alerts", e.target.checked);
            });

            // Fullscreen change event
            document.addEventListener("fullscreenchange", () => {
                const fullScreenBtn = document.getElementById('fullScreenBtn').querySelector('i');
                if (!document.fullscreenElement) {
                    fullScreenBtn.classList.remove('fa-compress');
                    fullScreenBtn.classList.add('fa-expand');
                } else {
                    fullScreenBtn.classList.remove('fa-expand');
                    fullScreenBtn.classList.add('fa-compress');
                }
            });

            // Speedometer toggle
            const toggleIcon = document.getElementById("toggleSpeedometer");
            const speedometerContainer = document.getElementById("speedometer-container");
            
            if (toggleIcon && speedometerContainer) {
                toggleIcon.addEventListener("click", () => {
                    speedometerContainer.classList.toggle("visible");
                    // Show current speed if we're replaying, otherwise show 0
                    if (speedometerContainer.classList.contains("visible")) {
                        if (isPlaying && replayIndex < replayData.length) {
                            const currentPoint = replayData[replayIndex];
                            const speed = parseFloat(currentPoint.speed) || 0;
                            drawSpeedometer(speed);
                        } else {
                            drawSpeedometer(0);
                        }
                    }
                });
            }
            
            // Heatmap toggle
            document.getElementById("heatmap-toggle").addEventListener("click", toggleHeatmap);
            
            // Check for URL parameters on page load
            window.addEventListener('load', () => {
                const urlParams = new URLSearchParams(window.location.search);
                if (urlParams.has('deviceId') && urlParams.has('from') && urlParams.has('to')) {
                    document.getElementById("device-id").value = urlParams.get('deviceId');
                    document.getElementById("from-date").value = urlParams.get('from');
                    document.getElementById("to-date").value = urlParams.get('to');
                    
                    // Auto-load history if parameters are present
                    loadHistory();
                }
            });
        }
		
		
		function drawSpeedometer(speed) {
			    if (!speedometerCtx) return;

			    const canvas = speedometerCanvas;
			    const ctx = speedometerCtx;

			    ctx.clearRect(0, 0, canvas.width, canvas.height);

			    const centerX = canvas.width / 2;
			    const centerY = canvas.height / 2;
			    const radius = canvas.width / 2 - 15;
			    const maxSpeed = 180;

			    // Background circle
			    ctx.beginPath();
			    ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
			    ctx.fillStyle = '#f0f0f0';
			    ctx.fill();

			    // Tick marks
			    for (let i = 0; i <= maxSpeed; i += 10) {
			        const angle = (Math.PI * (i / maxSpeed)) * 1.5 + 0.75 * Math.PI;
			        const x1 = centerX + (radius - 10) * Math.cos(angle);
			        const y1 = centerY + (radius - 10) * Math.sin(angle);
			        const x2 = centerX + radius * Math.cos(angle);
			        const y2 = centerY + radius * Math.sin(angle);

			        ctx.beginPath();
			        ctx.moveTo(x1, y1);
			        ctx.lineTo(x2, y2);
			        ctx.lineWidth = (i % 20 === 0) ? 2 : 1;
			        ctx.strokeStyle = '#333';
			        ctx.stroke();

			        // Speed numbers
			        if (i % 20 === 0) {
			            const labelX = centerX + (radius - 25) * Math.cos(angle);
			            const labelY = centerY + (radius - 25) * Math.sin(angle);
			            ctx.font = '10px Arial';
			            ctx.fillStyle = '#000';
			            ctx.textAlign = 'center';
			            ctx.textBaseline = 'middle';
			            ctx.fillText(i.toString(), labelX, labelY);
			        }
			    }

			    // Needle
			    const needleAngle = (Math.PI * (speed / maxSpeed)) * 1.5 + 0.75 * Math.PI;
			    const needleX = centerX + (radius - 30) * Math.cos(needleAngle);
			    const needleY = centerY + (radius - 30) * Math.sin(needleAngle);

			    ctx.beginPath();
			    ctx.moveTo(centerX, centerY);
			    ctx.lineTo(needleX, needleY);
			    ctx.lineWidth = 3;
			    ctx.strokeStyle = '#ff0000';
			    ctx.stroke();

			    // Center hub
			    ctx.beginPath();
			    ctx.arc(centerX, centerY, 6, 0, 2 * Math.PI);
			    ctx.fillStyle = '#222';
			    ctx.fill();

			    // Text
			    ctx.font = "bold 14px Arial";
			    ctx.fillStyle = "#000";
			    ctx.textAlign = "center";
			    ctx.fillText(`${Math.round(speed)} km/h`, centerX, centerY + 40);

			    // Update external speed text
			    const speedDisplay = document.getElementById("speedDisplay");
			    if (speedDisplay) {
			        speedDisplay.innerHTML = `<b>Speed: ${Math.round(speed)} km/h</b>`;
			    }
			}

			
			document.addEventListener("DOMContentLoaded", () => {
											    const urlParams = new URLSearchParams(window.location.search);
											    const deviceId = urlParams.get("deviceId");

											    if (deviceId) {
											        const searchBar = document.getElementById("device-id");
											        if (searchBar) searchBar.value = deviceId;
											    }
											});
    </script>
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>